[X] STREAM, USE ONE SLOT...done
[X] SET MAIN TEMPLATES TO ALWAYS INHERIT FROM NEW EVEN WITH OVER WRITE...done

compile
encrypt compilation with random key, random IV
chunk
encrypt all with randomBytes of 32, store random bytes in dummy file // 256 bits
randomise names, get mapping to dummy file
compile all with encrypted dummy file with pbkdf2 hashed key

extract dummy file
try decrypting dummy file
if successful, decrypt each chunk with random passwords specified within dummy file
order the random chunks
merge all in order specified by dummy file

// encrypted dummy file     : dummy.xmap
// container file           : container.xbit

model DataSpec -> {
  iv     : String<Buffer<16 rand byte> as hex>,
  tag    : String<Buffer<16 bytes> as hex>,
  file   : String<Buffer<16 rand byte> as hex> + ".xpart",
  size   : Number,
  oldFile: String;
}

model root impl DataSpec{iv, tag, file} -> {
  key : String<Buffer<32 random bytes> as hex>,
  salt: String<Buffer<32 bytes> as hex from String<!/\w+@\w+:\w+/>>
  chunks: DataSpec[50]
}

// Checkout Intricate STAT

ByteLace
ByteFabric

archive([files])
  .pipe(cryptEngine)
  .pipe(chunker.use(
    'crypto',
    () => cryptEngine)
  )
  .pipe(chunker.fiss("./file.txt"))

Can I mount a block file system as a stream


create truncated block of X bytes
format with the BF2S ByteFabric File System
Add Contents into this FS
Create a tarball of the image
Chunkify the tarball
Wrap in a tarball

=> BYTESTASH CONTAINER

Read chunk bytes from a tarball
Merge these chunk bytes
Mount the Fabric FS from the resulting tarball

=> DECRYPT

each chunk, random IV
5 chunks, 1 random salt
50 Chunks, 1 Encrypted Stash


archiver
tar-fs
lodash
readline-sync
chalk
ansi-styles
bluebird

(callback) ->
  let compileStream = compile(inputFolder:string, options:{}) => ReadableStream{};
  if (streamDirect)
    compileStream
      .pipe(WriteStream<tmpfile:string>)
      .on("finish", () => callback(ReadStream<tmpfile:string>));
  else callback(compileStream);
(
  () ->
    inStream
      .pipe(ReadChunker{...options}.use(label:string, function: () => Duplex))
      .pipe(:ReadChunker.fiss(cacheFolder))
);

[ ] Add detection for zip files, so ignore forced compression to save time
